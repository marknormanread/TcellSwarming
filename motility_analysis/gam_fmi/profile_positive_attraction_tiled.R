#!/usr/bin/env Rscript
#
# Constructs and plots GAM models of how cells in the "tiled" data sets resond to the bolus. 
#
# The raw data needed by this script is generated by profile_positive_attraction_helper.py 
# (which is in turn called from profile_positive_attraction_tiled.py)
#
# Some advice from Kari, who adapted the GAM methodology for the Simpson group for nutritional geometry:
#
# One additional point. I noticed from the script files that you have experimented with the “k-values”  of GAMs. 
# The k is the number of degrees of freedom allowed for the spline (or combination of splines in the case of 
# interactions) to use to control the “wiggliness”. Therefore, care must be taken to not artificially constrain this 
# parameter. Generally, the advice is to keep it as large as possible. This is because the inherent penalty function 
# of the GAM will downgrade the k to a value that is supported by the data. But it cannot do the other way around; 
# i.e. to increase the k if it has originally been too low (except if the model has far too few parameters).
#
# For these multidimensional spaces, especially when you wish to have the breakdown to main effects and interactions 
# with corresponding p-values, it is sometimes difficult to set the balance of the k’s for different spline terms. What 
# I have used in the original script is a result of a bit of experimentation with the data that we had at the time. It 
# would be easier to define k when not breaking down the terms to main effects and interactions and I usually do so for 
# explorative purposes – I am not often very interested if a main effect is significant, i.e. about the p-value, but 
# interpret the response outcome from the response surface fitted, and just ensure the model as such is better than a 
# simpler model (ultimately just predicting the mean). But, I see that many journals with conventional statistics 
# editors would require p-values and the latter technique will only provide one – whether the overall GAM is 
# significant or not. But GAMs are programmed to provide a parsimonious model and therefore the breakdown is often 
# unnecessary for understanding the response.
#
# Mark N. Read, 2018
#
# Clear the R environment.
rm(list=ls())


require(mgcv)
require(sp)  # used in findConvex
require(fields)  # provides colorbar.plot()

setwd('~/dropbox_usyd/projects/biro/neutroswarm/imaris/')

# data_dir = 'side_bolus_tiled/cognate2_positive_attraction_tiled2/arrest_coeff_filter_0.80'
data_dir = 'positive_attraction/2016_05_03_Positive_control_1/arrest_coeff_filter_0.80'
# data_dir = 'side_bolus_tiled/non_cognate3/arrest_coeff_filter_0.80'


# Pooled experients
# These are the ideal values
# instant_FMI_min = -0.1  # These are the ideal values
# instant_FMI_max = 0.2
# track_FMI_min = -0.2 
# track_FMI_max = 0.3
# However, beacuse of how we are using zlim in image.plot to centre on white, we instead need to set max and min
# equally far from zero
# instant_FMI_min = -0.2
# instant_FMI_max = 0.2
# track_FMI_min = -0.35
# track_FMI_max = 0.35

# Individual experiments
# These are the ideal values
# instant_FMI_min = -0.3
# instant_FMI_max = 0.4
# track_FMI_min = -0.3
# track_FMI_max = 0.7
# However, beacuse of how we are using zlim in image.plot to centre on white, we instead need to set max and min
# equally far from zero
instant_FMI_min = -0.4
instant_FMI_max = 0.4
track_FMI_min = -0.7
track_FMI_max = 0.7

# Landscape colours
rgb.palette = colorRampPalette(c("red","white","blue"),space="Lab",interpolate="linear")
no.cols = 256
resolution = 300	# resolution along each axis.
# Z transform puts both variables on the same scale, thereby ensuring error characteristics in the GAM apply equally 
# to both. 
z_transform = FALSE


# Contains observations of cell spatio-termporal location, and chemotactic behaviour w.r.t. swarm. 
# Must have columns: c
#   'dist_bolus': distance from the bolus. 
#   'absolute_time': time since experiment began. 
##   'track_id', 
##   'fmi': forward migration index of the track, based on overall displacement.
#   'instant_fmi': forward migration index based on displacement at given time increment.
#   'angle_bolus' : angle with respect to the bolus. 
#   'speed': instantaneous speed at given time increment. 
#   'turn_speed': instantaneous rotational velocity at given tiem increment. 
stats = read.csv(file=paste(data_dir, '/chemotactic_response.csv', sep=''), header=TRUE, sep=",")


constructGAM = function(responseName, raw_data, summaryFP=NULL) 
{
  k1 = 10
  k2 = 100
  mod = gam(eval(parse(text=responseName)) ~ 
          # Uncomment if you want to decompose prediction into specific inteactions and components, 
          # and get p-values for them. This is not actually necessary. 
          # Can use either the splines approach, or the tensor product approach. If your explanatory variables do not lie
          # on the same scale (and ours don't, time 0-120, distance 0-1200) tensor product can be more appropriate. 
          # We can rescale. However, it is not at all clear what the most statistically justified approach would be, 
          # both can be seen as valid. 
          # Without interaction terms the graphs look "squarish". Not surprising, good that this is confirmed. 
        
            # This appears to be the best option. Highest deviance explained (still low, 2%) and best shows the trends of the heatmaps. 
            #  s(dist_bolus, k=k1, bs="tp")
            # +s(absolute_time, k=k1, bs="tp")
            # +s(dist_bolus,absolute_time, k=k2, bs="tp"),
          
          # Allow inference of K. 
          # s(dist_bolus, bs="tp")
          # +s(absolute_time, bs="tp")
          # +s(dist_bolus,absolute_time, bs="tp"),
          
          # On its own, with no k specified, these landscapes have no shape, and have lowest deviance explained I've
          # seen yet. Don't proceed with this. 
          # s(dist_bolus,absolute_time, bs="tp"),
            
          # tensor product. Looks good with k unspecified. K=30 is quite noisy, but deviance explained highest seen.
          te(dist_bolus, absolute_time),
          
          # Worst approach thus far, unspecified K. 
          # ti(dist_bolus, absolute_time, k=30),
            
          data=raw_data)
  
  if (!is.null(summaryFP))  # NULL stops printing of this. 
  {
    sink(file=paste(summaryFP, '.txt', sep=''))
    print(summary(mod))
    sink() 
  }
  return(mod)
}
# 
# draw <- function(response, xs, ys, path, xlab, ylab, sub='', whiteCentred=NULL)
# {
#   # Draw the landscape
#   nlev = 8  # Number of contour line heights. 
#   colMap = rgb.palette(no.cols)
#   mn = min(c(unlist(response)), na.rm=TRUE)  # The minimum and maximum values enountered in the fit. 
#   mx = max(c(unlist(response)), na.rm=TRUE)
#   pdf(paste(path, '.pdf', sep=''))  # Make a PDF, save to path.
#   par(cex=1.5)  # Make text bigger on plot
#   # Which colours in the colMap to assign to exteme values in the response. 
#   # This actually uses all of them. 
#   # Below we use a subset to centre white on a given value. 
#   colMapLocs = (range(unlist(response), na.rm=TRUE) - mn) / (mx - mn) * no.cols
#   cols = colMap[colMapLocs[1]:colMapLocs[2]]
#   surf <- matrix(response, nrow=resolution)  # Re-shapes response into a matrix, values for the image. 
#   px <- pretty(xs)  # the tick locations, made pretty (0  5 10 15 20 25 30)
#   py <- pretty(ys)
#   x.new <- seq(min(px), max(px), len=resolution)	# x and y locations where coloured boxes are to be drawn. 
#   y.new <- seq(min(py), max(py), len=resolution)
#   
#   if (! is.null(whiteCentred))
#   {
#     # The following will centre the middle color in the heatmap's range of possible colors to the specified number. 
#     # The middle color is usually white here. 
#     #
#     # Colours are indexed by numbers (e.g. 0..256). The maximum and minimum values to be drawn on the image
#     # are mapped to these extremes. To centre white on a particular value, need to adjust the indexes that the image commmand
#     # can use. 
#     #
#     # For example, if mn=0% and mx=120%, then white will be set to be 60%. However, if white is instead to be mapped
#     # to 50%, then the lowest color index should be mapped to -20%, not 0%. Some of the color index values need to 
#     # be removed to compensate for mx lying further away from 50% than mn. 
#     #
#     # If color indexes were [0..256], then 128 represents 50%. 256 maps to 120%. 0 has been mapped to -20%, however 
#     # the smallest value that the image command is going to see is 0%. Hence, range of colors that map can use must
#     # start from index 37. (because 120--20 = range of 140%. mn lies 20% above lowP, hence range must start from
#     # 20/140=36.6.)
#     highP <- whiteCentred		# temp variables. Assigned to response variables such that white lies on 'whiteCentred'
#     lowP <- whiteCentred
#     mxExcess <- mx - whiteCentred		# calcualte whether mn or mx lies further away from 'whiteCentred'
#     mnExcess <- whiteCentred - mn 			
#     if (mxExcess > mnExcess)			# adjust highP and lowP
#     {
#       highP <- mx
#       lowP <- whiteCentred - mxExcess
#     } else {
#       lowP <- mn
#       highP <- whiteCentred + mnExcess
#     }
#     # EXPLAIN, THIS IS COMPLEX. 
#     range <- highP-lowP
#     lowProp <- (mn-lowP) / range
#     highProp <- (mx-lowP) / range
#     locsRange <- colMapLocs[2] - colMapLocs[1]
#     lowIndex <- (locsRange * lowProp) + colMapLocs[1]		
#     highIndex <- (locsRange * highProp) + colMapLocs[1]
#     cols <- colMap[lowIndex:highIndex]
#   }
#   # Image creates a pixelised plot, like a bitmap. 
#   image(x.new, y.new, surf, col=cols, xlab=xlab, ylab=ylab, sub=sub, axes=FALSE)
#   axis(1)  # Draw the axes
#   axis(2)
#   # labcex adjusts font size for contour lines. 
#   # contour(x.new, y.new, surf, add=TRUE, levels=pretty(range(mn, mx), 8), labcex=1.5)		
#   # color.bar(lut=cols, min=mn, max=mx)
#   colorbar.plot(x=100,y=100, strip=seq(mn, mx), strip.width=10, col=cols)
#   dev.off()
# }

# z must be a two dimensional matrix. Length of each dimension must match x and y respectively. 
plot_surface <- function(x, y, z, 
                         xlab='Distance to bolus (um)', ylab="Experiment time (min)", 
                         centred_val=NULL, path, xlim=range(x), ylim=range(y),
                         min_val=min(z, na.rm=TRUE), max_val=max(z, na.rm=TRUE))
{
  source("diverge_anchored.R")
  colmap <- NULL
  zlim = NULL
  if (! is.null(centred_val)) {
    # colmap <- diverge_anchored(min_val=min_val, max_val=max_val, whiteCentred=centred_val, num_colours=256)
    # colmap <- diverge_anchored(min_val=-0.1821632, max_val=10, whiteCentred=centred_val, num_colours=10)
    colmap = designer.colors(250, c("blue","white", "red"))
    zlim=c(min_val, max_val)
  }
  pdf(paste(path, '.pdf', sep=''))
  # Automatically includes a colour bar
  image.plot(x=x, y=y, z=z, xlab=xlab,  ylab=ylab, col=colmap, 
             xlim=xlim, ylim=ylim, zlim=zlim)
  contour(x=x, y=y, z=z, add=TRUE, nlevels=1,
          levels=pretty(range(min(z, na.rm=TRUE), max(z, na.rm=TRUE)), 4), col='dark grey', lwd=2.0, labcex=1.1)

  # Heavier weight for z=centred_val, if selected.
  if (! is.null(centred_val)) {
    contour(x=x, y=y, z=z, add=TRUE, nlevels=1, levels=c(centred_val), lwd=2.0, labcex=1.1)
  }
  dev.off()
}
  
findConvex = function(x, y, names)
{
  hull = cbind(x, y)[chull(cbind(x ,y)),]
  # Use if you're willing to have some bleed around the areas that are plotted. 
  #px = pretty(x)			# Returns same number of items as x, but rounded and evenly spaced.
  #py = pretty(y)
  x.new = seq(min(x), max(x), len=resolution)
  y.new = seq(min(y), max(y), len=resolution)
  ingrid = as.data.frame(expand.grid(x.new,y.new))
  Fgrid = ingrid
  Fgrid[(point.in.polygon(ingrid[,1], ingrid[,2], hull[,1], hull[,2])==0),] = NA
  names(Fgrid) = names
  return(Fgrid)
}


generatePlane <- function(x, y, names)
{
  # Uncommenting results in nicer rounder numbers for x and y axis limits, but results in GAM predictions outside of 
  # range of data on which they were trained, which can give misleading results. 
  # px <- pretty(x)  # Returns same number of items as x, but rounded and evenly spaced.
  # py <- pretty(y)
  x_new <- seq(min(x), max(x), len=resolution) # high res datapoints
  y_new <- seq(min(y), max(y), len=resolution)
  coordinates <- as.data.frame(expand.grid(x_new, y_new))
  names(coordinates) <- names
  return(list(coordinates=coordinates, x=x_new, y=y_new))
}


# Common to all plots. 
result = generatePlane(x=stats$dist_bolus, y=stats$absolute_time, c('dist_bolus', 'absolute_time'))
coordinates = result$coordinates  # All coordinates as rows in a dataframe. 
x_points = result$x  # X-axis values used in the grid forming coordinates. 
y_points = result$y  


if (z_transform)
{
  # Save the original values so they can be replaced. 
  stats$orig_dist_bolus = stats$dist_bolus
  stats$orig_absolute_time = stats$absolute_time
  
  # Calculate scaled explanatory variables
  stats$scaled_dist_bolus = scale(stats$dist_bolus, center=TRUE, scale=TRUE)
  stats$scaled_absolute_time = scale(stats$absolute_time, center=TRUE, scale=TRUE)
  
  # Replace with scaled variables for GAM construction. 
  stats$dist_bolus = stats$scaled_dist_bolus
  stats$absolute_time = stats$scaled_absolute_time

  # Replaces previous calculations (which may omit some points in the plane lying outside the boundaries of known data points)
  result = generatePlane(x=stats$dist_bolus, y=stats$absolute_time, c('dist_bolus', 'absolute_time'))
  coordinates = result$coordinates  # All coordinates as rows in a dataframe. 
}


modelName = 'R_track_fmi'  # Plotting track FMI at each temporal position a track is registered at.
modelPath = paste(data_dir, '/', modelName, sep='')
model = constructGAM(responseName='track_fmi', raw_data=stats, summaryFP=modelPath)
fit = predict(model, coordinates, type="response")  # Fit is a 1D array.  
z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix. 
plot_surface(x=x_points, y=y_points, z=z, centred_val=0, path=modelPath, min_val=track_FMI_min, max_val=track_FMI_max)


modelName = 'R_instant_fmi'
modelPath = paste(data_dir, '/', modelName, sep='')
model = constructGAM(responseName='instant_fmi', raw_data=stats, summaryFP=modelPath)
fit = predict(model, coordinates, type="response")  # Fit is a 1D array.
z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix.
plot_surface(x=x_points, y=y_points, z=z, centred_val=0, path=modelPath, min_val=instant_FMI_min, max_val=instant_FMI_max)

# Performed as a sanity check for JH's swarm metric; is the swarm metric's "f" over-estimating the average velocity to
# the bolus? We can estimate F here. If the instant_fmi captures the proportion of a track's displacement along the -x
# axis, then dividing the translational speed by this proportion will capture the velocity along the -x axis. This is
# akin to F. When we then plot a GAM of this data, we should capture the "average" across all cells at a given distance
# from the bolus. This is very much what F is trying to do. 
modelName = 'R_f'
if (! 'f' %in% names(stats))
{  
  # not supplied, so calculate
  stats$f = stats$speed * stats$instant_fmi
}
modelPath = paste(data_dir, '/', modelName, sep='')
model = constructGAM(responseName='f', raw_data=stats, summaryFP=modelPath)
fit = predict(model, coordinates, type="response")  # Fit is a 1D array.
z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix.
plot_surface(x=x_points, y=y_points, z=z, path=modelPath)

# 
# modelName = 'R_angle_bolus'
# modelPath = paste(data_dir, '/', modelName, sep='')
# model = constructGAM(responseName='angle_bolus', raw_data=stats, summaryFP=modelPath)
# fit = predict(model, coordinates, type="response")  # Fit is a 1D array.
# z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix.
# plot_surface(x=x_points, y=y_points, z=z, centred_val=90, path=modelPath)
# 
# 
# modelName = 'R_speed'
# modelPath = paste(data_dir, '/', modelName, sep='')
# model = constructGAM(responseName='speed', raw_data=stats, summaryFP=modelPath)
# fit = predict(model, coordinates, type="response")  # Fit is a 1D array.
# z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix.
# plot_surface(x=x_points, y=y_points, z=z, centred_val=NULL, path=modelPath)
# 
# 
# modelName = 'R_turn_speed'
# modelPath = paste(data_dir, '/', modelName, sep='')
# model = constructGAM(responseName='turn_speed', raw_data=stats, summaryFP=modelPath)
# fit = predict(model, coordinates, type="response")  # Fit is a 1D array.
# z = matrix(fit, ncol=length(x_points))  # for plotting, need to convert the 1D array to a 2D matrix.
# plot_surface(x=x_points, y=y_points, z=z, centred_val=NULL, path=modelPath)

