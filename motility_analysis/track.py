"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Mark N. Read, 2017.


Captures a single spatio-temporal observation. These can be collected together into tracks.

Mark N. Read, 2017
"""
import math
import numpy as np
from . import geometry
from .position import Position as Position


class Track:
    """ Captures a single cell's motility through space as a time series of positional observations. """
    def __init__(self, id, timestep_s, speed_warning=float('Inf')):
        """
        :param id: identification of tracked cell, generated by IMARIS.
        :param timestep_s:
        :param speed_warning: threshold for track speeds at which user is alerted.
        """
        # Many of the calculations that follow can be computationally expensive for large datasets. 
        # As such their calculation is deferred until request. Use of 'None' indicates this. 
        self.ID = id
        self.positions = []  # list of Position objects, the cell's position in space and time.
        self.timestep_s = timestep_s
        self.timestep_min = timestep_s / 60.0  # the time step, in minutes.
        self.broken = False  # True if there is missing spatial position data for this track.

        self.displacement = None  # displacement of the entire track.
        self.displacement_vector = None  # vector representing the components of the net displacement, [dx, dy, dz]
        # Angle corresponding to the track's displacement (from start to finish) in the xy plane. 
        self._arctan2_xy = None  
        # used in calculating the displacement autocorrelations, as in Banigan 15, PLoS Comp Bio
        self.mean_disp_autocorr = None
        self.displacement_autocorrelation = None  # dict[deltaT] = normalised displacement autocorrelation

        self.duration_min = None  # duration for which this track existed, in minutes.
        self.duration_sec = None  # Duration for which this track existed, in seconds.
        self.length = None
        self.meander = None
        self.displacements = []  # how far the cell moves each time step.
        self.fmi = None  # forward migration index for the track
        # used for calculating displacements occurring over a given time interval. Displacements are captured from
        # anywhere in the time series, not only absolute time from 0.
        self._deltaT_displacements = None   # [deltaT] = list( displacements )
        self._deltaT_displacements_sq = None   # same as above, but all values are squared.
        # same as deltaT_displacements, but broken down into each axis. [deltaT] = list( displacement )
        self._deltaT_displacements_X = None
        self._deltaT_displacements_Y = None
        self._deltaT_displacements_Z = None
        self.arrest_coefficient = None  # proportion of track with instantaneous velocity < threshold (2. by default)

        self.interpolate = None  # stores original setting in case track must be re-summarised at later point.
        self.speed_warning = speed_warning  # warn user of cells faster than this threshold

    def log_position(self, x, y, z, time, timeIter):
        """
        Called when building a track whilst iterating through and input data file.
        :param time: represents a cumulative count of time since the track began (which is not necessarily the same as
        when other tracks began).
        """
        if self.positions:   # check list is not empty.
            # deal with cases where a record is missing because IMARIS lost a cell, but found it thereafter.
            while self.positions[-1].timeID + 1 < timeIter:
                # if previous entry was not one iteration prior to this one, then add in a placeholder. Most likely
                # IMARIS lost the cell for a time.
                self.positions.append(Position(x=None, y=None, z=None, time_s=time, timeID=timeIter))
                self.broken = True   # record that there is missing data for this track.
        self.positions.append(Position(x, y, z, time, timeIter))

    def mean_speed(self):
        speeds = [p.speed for p in self.positions if (p.speed is not None and not math.isnan(p.speed))]
        if speeds:  # if list is not empty
            return np.mean(speeds)
        return float('nan')

    def median_speed(self):
        """ median speed of this track """
        speeds = [p.speed for p in self.positions if (p.speed is not None and not math.isnan(p.speed))]
        if speeds:  # if list is not empty
            return np.median(speeds)
        return float('nan')

    def irq_speed(self):
        """ inter-quartile range of speeds of this track """
        speeds = [p.speed for p in self.positions if (p.speed is not None and not math.isnan(p.speed))]
        if speeds:  # check list is not empty.
            q75, q25 = np.percentile(speeds, [75, 25])
            return q75 - q25    # IRQ is the difference between 75th and 25th percentiles.
        return float('nan')

    def median_turn(self):
        turns = [p.turn for p in self.positions if (p.turn is not None and not math.isnan(p.turn))]
        if turns:   # check list not empty
            return np.median(turns)
        return float('nan')

    def irq_turn(self):
        turns = [p.turn for p in self.positions if (p.turn is not None and not math.isnan(p.turn))]
        if turns:
            q75, q25 = np.percentile(turns, [75, 25])
            return q75 - q25
        return float('nan')

    def median_roll(self):
        rolls = [p.roll for p in self.positions if (p.roll is not None and not math.isnan(p.roll))]
        if rolls:  # check list not empty
            return np.median(rolls)
        return float('nan')

    def irq_roll(self):
        rolls = [p.roll for p in self.positions if (p.roll is not None and not math.isnan(p.roll))]
        if rolls:
            q75, q25 = np.percentile(rolls, [75, 25])
            return q75 - q25
        return float('nan')

    def get_arctan_xy(self):
        """ Deferred calculation, performed upon request. """
        if self._arctan2_xy is None:  # Not yet been set. 
            # Arctan2(dy, dx) (NOTE y provided first) returns 0 degrees = parallel along x axis in positive direction.
            # Increasing angles are anticlockwise from vector (x=1, y=0)
            self._arctan2_xy = np.arctan2(self.displacement_vector[1], self.displacement_vector[0])
            # Arctan2 returs values -pi ... pi, this adjusts to range of 0..2pi. 
            if self._arctan2_xy < 0:
                self._arctan2_xy += 2 * np.pi
        return self._arctan2_xy

    def get_num_samples(self):
        """  Returns the number of time-samples comprising this track.  """
        return len(self.positions)

    def interpolate_missing_data(self):
        """
        Interpolates track locations (positions) for times at which no data exists. This happens when IMARIS loses
        track of a cell. Performs a linear interpolation (straight line, positions evenly spaced along it).
        """
        if not self.broken:
            return
        # have to deal with multiple breaks.
        start_i = 0  # looking for the start of a break (the last 'tracked' position)
        while start_i < len(self.positions)-1:  # -1 because the last item can't be un-tracked.
            # iterate from start of the list to the end of the list.
            next_p = self.positions[start_i + 1]
            if not next_p.tracked():
                # start_i is last tracked data point before track lost. Ignore interpolated data.
                end_i = start_i + 1  # end is the first lost data point.
                while not self.positions[end_i].tracked():
                    # search for the start of tracked data. end_i will point to the first tracked item.
                    end_i += 1
                # at this point, end_i points to the start of tracked data. Must interpolate between.
                # number of gaps (steps) missing. If there are 4 missing point, then there are 5 gaps.
                # eg, 5...(6)...7. If 6 is missing, then 1 missing data point, two gaps. 7 - 5 = 2.
                missing_steps = end_i - start_i
                dx = self.positions[end_i].x - self.positions[start_i].x
                dy = self.positions[end_i].y - self.positions[start_i].y
                dz = self.positions[end_i].z - self.positions[start_i].z
                dxi = dx / missing_steps
                dyi = dy / missing_steps
                dzi = dz / missing_steps
                # assign the missing data points through interpolation.
                for subject_i in range(start_i + 1, end_i):   # goes up to end_i, but does not include it.
                    self.positions[subject_i].x = self.positions[subject_i - 1].x + dxi
                    self.positions[subject_i].y = self.positions[subject_i - 1].y + dyi
                    self.positions[subject_i].z = self.positions[subject_i - 1].z + dzi
                    self.positions[subject_i].interpolated = True
                start_i = end_i
            else:
                start_i += 1
        self.broken = False  # No longer a broken track

    def summary_stats(self, interpolate=False, arrest_coeff_threshold=2., fmi_direction=None):
        """
        Call when all positions have been logged for the track. It will calculate speeds, length, displacement,
        meandering indexes, etc.
        arrest_coeff_threshold is speed, in um/min. The arrest coefficient is the proportion of time a track spends with
        an instantaneous velocity below this threshold.

        :fmi_direction: Forward migration index (bias in displacement towards a given direction) can be calulated with
        respect to the given vector. This vector should originate from the cell's current location. Ie, to analyse
        movement towards the positive x axis, supply the vector [1, 0, 0].
        """
        # Safety, in case the times are in the wrong order (if the input data file is screwy).
        self.positions.sort(key=lambda pos: pos.time_s)

        if interpolate:
            # Interpolation very useful for calculating summary stats for poor-quality imaging datasets where cells are 
            # frequently 'lost'.
            # Note however that linear interpolation results in a lot of zero turns and constant (identical) speeds.
            # Interpolated speed and turn data should probably be ignored.
            self.interpolate_missing_data()
        # Calculate track duration, and convert from seconds to minutes
        try:
            self.duration_min = self.positions[-1].time_m - self.positions[0].time_m
            self.duration_sec = self.duration_min * 60.
        except Exception:
            print('something went wrong in calculating track duration')
            print(self.positions[-1])
            print(self.positions[0])
        # Statistics pertaining to individual positions (must exist >=2)
        for j in range(1, len(self.positions)):
            # Track must have at least 2 positions to proceed here.
            pi = self.positions[j-1]
            pj = self.positions[j]
            if pi.tracked() and pj.tracked():  # Can only be calculated for consecutive tracked positions.
                diff = (pj.x - pi.x,
                        pj.y - pi.y,
                        pj.z - pi.z)
                pj.displacementVector = diff
                length = geometry.vector_length(diff)

                pj.displacement = length
                # Not calculated for time step = NaN, because only 1 position (see above for loop).
                # Exclude this calculation for interpolated data.
                if not (pj.interpolated or pi.interpolated):
                    pj.speed = length / self.timestep_min  # Speed in microns / minute.
                    if pj.speed > self.speed_warning:
                        print('Warning! Found track with very high speed! speed {s:f} ID {id:f} position {pos:d}'
                              .format(s=pj.speed, id=self.ID, pos=j))
        # Calculate track displacement. Calculated even if this is a broken track.
        v = (self.positions[-1].x - self.positions[0].x,
             self.positions[-1].y - self.positions[0].y,
             self.positions[-1].z - self.positions[0].z)
        self.displacement_vector = v  # Displacement along each axis
        self.displacement = geometry.vector_length(v)
        # Calculate track length. Can only do this for unbroken tracks (can't know true length if missing spatial
        # position data).
        if not self.broken:
            self.length = sum(p.displacement for p in self.positions if p.displacement is not None)
            if self.length != 0.0:
                self.meander = self.displacement / self.length
        self._calculate_turns()
        self._calculate_roll_rotations()
        self.interpolate = interpolate  # Record fact that this track has interpolated data
        self._calculate_displacement_autocorrelation()
        self._calculate_arrest_coefficient(arrest_coeff_threshold)
        if fmi_direction:
            self._calculate_forward_migration_index(fmi_direction)

    def _calculate_forward_migration_index(self, fmi_vector):
        """
        The proportion of the displacement that occurs in the direction of the given vector.

        The forward migration index (FMI) is calculated as the length of the displacement vector projected onto the
        given fmi_vector, divided by the length of the displacement vector.

        :param fmi_vector: Only the direction matters, this need not be unit length.
        """
        def _fmi_helper(displacement_vector, displacement):
            projected = geometry.vector_projection(displacement_vector, fmi_vector)
            if displacement != 0.:
                fmi = geometry.vector_length(projected) / displacement
                if geometry.angle_between_vectors(displacement_vector, fmi_vector) > 90.:
                    fmi = -fmi
                return fmi
            else:
                return None  # Cannot be calculated with dispacement == 0. 

        self.fmi = _fmi_helper(self.displacement_vector, self.displacement)
        # Calculate instantaneous forward migration index
        for pos in self.positions:
            if pos.displacement is not None:
                pos.instant_fmi = _fmi_helper(pos.displacementVector, pos.displacement)

    def _calculate_arrest_coefficient(self, arrest_coeff_threshold=2.):
        """
        Proportion of track with instantaneous velocity < threshold. Counts only those position data for which an
        instantaneous velocity has been calculated. This excludes the last position by definition.
        """
        count = 0  # total count
        arrest_count = 0
        for pos in self.positions:
            if pos.speed is not None:
                count = count + 1
                # calculate and store whether this position corresponds to blebbing or genuine cell movement
                pos.meets_arrest_coeff_threshold = pos.speed >= arrest_coeff_threshold
                if pos.speed < arrest_coeff_threshold:
                    arrest_count = arrest_count + 1

        if count > 0:
            self.arrest_coefficient = float(arrest_count) / count

    def _calculate_displacement_autocorrelation(self):
        """
        See Banigan 15, PLOS Computational Biology, for details and calculation.
        This finds the correlation between time-step displacements a given time apart.
        There's a lot going on here, so, some specifics.
        Firstly, a single autocorrelation value is calculated individually for each cell individually.
        Hence, for a given time interval, all possible correlations in the time series are calculated for a given cell.
        The mean correlation is extracted from this, and normalised against the mean directional movement (all
        displacements at any time correlated with themselves).
        These data are then pooled for all the cells. Hence, for any given time-distance, say, 3 min, a distribution
        of correlations are returned, with one value per cell.
        creates a dictionary: [dt] = list( autocorrelations, one value per cell ).
                 dt = time distance used in correlation.
        """
        self.displacement_autocorrelation = dict()

        # Used for normalization, this is the average of all displacements dot producted with themselves.
        # First position doesn't have a displacement, so skip it.
        meanAc = np.mean([geometry.dot_product(pos.displacementVector, pos.displacementVector)
                          for pos in self.positions[1:] if pos.displacementVector is not None])
        self.mean_disp_autocorr = meanAc

        # Scan over deltaTs.
        for d in range(1, len(self.positions) - 1):
            deltaT = d * self.timestep_s
            acs = []
            # Process all possible autocorrelations for the given deltaT
            for i in range(1, len(self.positions) - d):
                j = i + d
                di = self.positions[i].displacementVector
                dj = self.positions[j].displacementVector
                if di is not None and dj is not None:
                    acs.append(geometry.dot_product(di, dj))
            meanAcDeltaT = np.mean(acs) / meanAc
            # Store for the track
            self.displacement_autocorrelation[deltaT] = meanAcDeltaT

    def _calculate_deltaT_displacements(self):
        """
         See Banigan 15, PLoS Computational Biology.
         Captures the distribution of displacements for a given time interval (dt).
         Both displacements along each component spatial axis {x, y, z} and net displacement are calculated.
         Note that disp_dt[timestep] = speeds distribution.

         Creates a dictionary: [dt] = list( displacements found for the given dt )
         :return:
         """        
        self._deltaT_displacements = dict()
        self._deltaT_displacements_sq = dict()
        self._deltaT_displacements_X = dict()
        self._deltaT_displacements_Y = dict()
        self._deltaT_displacements_Z = dict()
        # Iterate over all possible delta Ts, in terms of recorded data (not actual time).
        for d in range(1, len(self.positions)-1):
            delta_t = d * self.timestep_s
            # These variables are dictionaries, indexed by delta_t.
            self._deltaT_displacements[delta_t] = []
            self._deltaT_displacements_sq[delta_t] = []
            self._deltaT_displacements_X[delta_t] = []  # Displacements in each component axis
            self._deltaT_displacements_Y[delta_t] = []
            self._deltaT_displacements_Z[delta_t] = []

            # Process all possible temporal locations where interval delta_t occurred.
            for i in range(0, len(self.positions)-d):
                # Can't be done for positions where cell was untracked.
                if self.positions[i+d].tracked() and self.positions[i].tracked():
                    dx = self.positions[i+d].x - self.positions[i].x
                    dy = self.positions[i+d].y - self.positions[i].y
                    dz = self.positions[i+d].z - self.positions[i].z
                    vector = (dx, dy, dz)
                    disp_sq = geometry.vector_length2(vector)
                    disp = np.sqrt(disp_sq)

                    self._deltaT_displacements[delta_t].append(disp)
                    self._deltaT_displacements_sq[delta_t].append(disp_sq)
                    # Component displacements along each axis.
                    self._deltaT_displacements_X[delta_t].append(dx)
                    self._deltaT_displacements_Y[delta_t].append(dy)
                    self._deltaT_displacements_Z[delta_t].append(dz)
        
    def get_deltaT_displacements(self):
        if self._deltaT_displacements is None:  # First request of calculation; uninitialised. 
            self._calculate_deltaT_displacements()
        return self._deltaT_displacements

    def get_deltaT_displacements_sq(self):
        if self._deltaT_displacements_sq is None:  # First request of calculation; uninitialised. 
            self._calculate_deltaT_displacements()
        return self._deltaT_displacements_sq

    def get_deltaT_displacements_X(self):
        if self._deltaT_displacements_X is None:  # First request of calculation; uninitialised. 
            self._calculate_deltaT_displacements()
        return self._deltaT_displacements_X

    def get_deltaT_displacements_Y(self):
        if self._deltaT_displacements_Y is None:  # First request of calculation; uninitialised. 
            self._calculate_deltaT_displacements()
        return self._deltaT_displacements_Y

    def get_deltaT_displacements_Z(self):
        if self._deltaT_displacements_Z is None:  # First request of calculation; uninitialised. 
            self._calculate_deltaT_displacements()
        return self._deltaT_displacements_Z

    def _calculate_turns(self):
        """
        Calculate the turns in the track, as degrees. There are two less of these than positions recorded, since no
        turn can be calculated for the first and last positions.
        """
        for j in range(1, len(self.positions)):
            # Track must have at least 2 positions to proceed here.
            pi = self.positions[j-1]
            pj = self.positions[j]
            # Must have both displacement vectors, but we exclude interpolated data (as it results in zero turns)
            if (pi.displacementVector and pj.displacementVector) and not (pi.interpolated or pj.interpolated):
                try:
                    # Rotation speed in degrees / min.
                    pj.turn = geometry.angle_between_vectors(pi.displacementVector, pj.displacementVector) \
                              / self.timestep_min
                except geometry.InvalidAngleException:
                    pass

    def _calculate_roll_rotations(self):
        """
        Calculate the rotational velocity of the cell's roll. This is done by considering three movement vectors, the
        previous, the current and the next. If we assume a cell always turns by changing it's pitch by turning in the
        y-x-plane (ie, turning around the z-axis), then the roll can be defined by how that plane changes when the
        cell rolls along its x-axis.

        The plane of pitch-shift is calculated between the previous and current displacement vectors, and then again
        for the current and next displacement vectors. The angle between these planes gives the roll.
        """
        for i in range(1, len(self.positions) - 1):
            # Track must have at least 2 positions to proceed here.
            pu = self.positions[i-1]
            pv = self.positions[i]
            pw = self.positions[i+1]
            if pu.displacementVector and pv.displacementVector and pw.displacementVector\
                    and not (pu.interpolated or pv.interpolated or pw.interpolated):
                u = pu.displacementVector
                v = pv.displacementVector
                w = pw.displacementVector
                # If at least one vector is zero-length, then roll can't be calculated.
                if pu.displacement > 0. and pv.displacement > 0. and pw.displacement > 0.:
                    # Projecting U onto V gives u1. u1 + u2 = u, hence we can calculate u2. u2 is the vector lying on
                    # the plane UV that is perpendicular to v.
                    u1 = geometry.vector_projection(u, v)
                    (u1x, u1y, u1z) = u1
                    u2 = (-1.0 * (u[0] - u1x),  # Invert this vector, so that it points away from v, not towards it.
                          -1.0 * (u[1] - u1y),  # Hence, both w2 and u2 will point away from v.
                          -1.0 * (u[2] - u1z))
                    # Do the same again for W onto V. u2 and w2 will both be perpendicular to v (just as u1 and w1 are
                    # parallel to it).
                    w1 = geometry.vector_projection(w, v)
                    (w1x, w1y, w1z) = w1
                    w2 = (w[0] - w1x,
                          w[1] - w1y,
                          w[2] - w1z)
                    if geometry.vector_length2(u2) * geometry.vector_length2(w2) != 0.0:
                        # Calculate the changes in roll, based on angles between successive orientations.
                        angle = geometry.angle_between_vectors(u2, w2)
                        # Rolling 180 degrees and then pitching in positive angle is the same as not rolling and
                        # applying a negative pitch. Don't want two ways of expressing the same data, so convert rolls
                        # accordingly. This can happen when a cell's movement crosses the x-axis, the cross product
                        # calculated to rotate v and w along the x-axis inverses, and so the cell appears up side down.
                        if angle >= 179.0: angle = 0.0  # use >178 to allow for precision errors.
                        rotVel = angle / self.timestep_min  # convert to rotational velocity.
                        self.positions[i].roll = rotVel
